# ****ΤΙΤΛΟΣ PROJECT : FACTOR****

***

## Περιγραφή
Το πρόγραμμα "Factor" είναι μια υλοποίηση του αλγορίθμου Pollard's Rho για την παραγοντοποίηση μικρών αλλά και μεγάλων ημιπρώτων αριθμών(μέχρι 27 ψηφία σε λιγότερο απο 10 δευτερόλεπτα). Ο αλγόριθμος Pollard's Rho χρησιμοποιείται στην κρυπτογραφία ,μιας και είναι πιο αποδοτικός από άλλες τεχνικές παραγοντοποίησης ημιπρώτων μεγάλου μεγέθους. Το συγκεκριμένο πρόγραμμα δέχεται έναν ημιπρώτο αριθμό ως είσοδο και αξιοποιεί τον αλγόριθμο Pollard's Rho για να βρει τους δύο πρώτους παράγοντες του. Ο αλγόριθμος έχει συνδυαστεί με μια σειρά μαθηματικών τεχνικών, όπως ο Ευκλείδειος αλγόριθμος για τον υπολογισμό του μέγιστου κοινού διαιρέτη (GCD), και άλλες αριθμητικές βελτιώσεις για την ταχύτερη αναζήτηση των παραγόντων.

Η εκφώνηση του συγκεκριμένου πρότζεκτ βρίσκεται [εδώ](https://progintro.github.io/assets/pdf/hw1.pdf) (άσκηση 3).

## Περιεχόμενα
- [Εγκατάσταση](#εγκατάσταση)
- [Χρήση](#χρήση)
- [Παραδείγματα](#Παραδείγματα-Εκτέλεσης)
- [Υλοποίηση](#Υλοποίηση)
- [Πηγές](#Πηγές)
- [Άδεια](#άδεια)

## Εγκατάσταση
Κατ' αρχάς αν έχετε ήδη ακολουθήσει τα βήματα εγκατάστασης από το πρόγραμμα "gcd calculator" ή από το πρόγραμμα "RSA" μεταβείτε απευθείας στο τμήμα κατασκευής του προγράμματος και συγκεκριμένα στο στάδιο "μετάβαση στο φάκελο του προγράμματος" και συνεχίστε από εκεί. Διαφορετικά, ακολουθήστε την παρακάτω διαδικασία από την αρχή.

Για να εκτελεστεί επιτυχώς το πρόγραμμα "FACTOR" θα χρειαστεί να μετατρέψετε τον πηγαίο κώδικα σε εκτελέσιμο αρχείο. Για να το πραγματοποιήσετε αυτό ακολουθήστε τα παρακάτω βήματα:
### **Πρόσθετες οδηγίες για χρήστες Windows** 
Αν χρησιμοποιείτε Windows, μπορείτε να χρησιμοποιήσετε το Windows Subsystem for Linux (WSL) για να εγκαταστήσετε τον gcc και το git με τα ακόλουθα βήματα:
- Εγκατάσταση WSL: Για να εκτελέσετε το πρόγραμμα, θα χρειαστείτε ένα τερματικό περιβάλλον Linux. Αν δεν έχετε ήδη εγκατεστημένο το WSL, μπορείτε να το εγκαταστήσετε ακολουθώντας τις οδηγίες [εδώ](https://learn.microsoft.com/en-us/windows/wsl/install).

- Ubuntu: Όταν εγκαταστήσετε το WSL ανοίξτε το Ubuntu χρησιμοποιώντας WSL.

- Εγκατάσταση git: Αφού εγκαταστήσετε WSL, μπορείτε να εγκαταστήσετε το git γράφοντας την παρακάτω εντολή στο τερματικό Linux:
```sh
sudo apt update
sudo apt install git
```

- Εγκατάσταση `gcc`: Για να μπορέσετε να τρέξετε το πρόγραμμα αυτό θα χρειαστεί να εγκαταστήσετε τον `gcc` μέσω των εντολών παρακάτω:
```sh
sudo apt install gcc
```
### **Κατασκευή προγράμματος**
1.  Αντιγράψτε το repository στον τοπικό σας υπολογιστή:
   ```sh
git clone git@github.com:progintro/hw1-Spyrosmaicho.git
```

2.    Μεταβείτε στον φάκελο του προγράμματος factor.c:  
```sh
cd factor/src
```
3.  Μεταγλωττίστε το πρόγραμμα factor.c με την παρακάτω εντολή:
```sh
gcc -O3 -Wall -Wextra -Werror -o factor factor.c -lm
```
Πλέον το πρόγραμμα είναι έτοιμο να εκτελεστεί.

## Χρήση
Για να λειτουργήσει το πρόγραμμα factor.c θα πρέπει να το τρέξετε με ένα ακριβώς ορίσμα στην γραμμή εντολών. Για να το εκτελέσετε, λοιπόν, χρησιμοποιήστε την παρακάτω εντολή:
```sh
./factor <semimprime>
```
όπου semiprime θα πρέπει να είναι ένας ημιπρώτος αριθμός στο διάστημα [0 , $2^{127}$].

Επιπλέον είναι σημαντικό να αναφερθεί ότι για να ελέγξετε τον κωδικό εξόδου του προγράμματος αφότου τερματιστεί, μπορείτε να πληκτρολογήστε την παρακάτω εντολή. 
```sh 
echo$?
```

## Παραδείγματα εκτέλεσης
Στην συγκεκριμένη ενότητα θα παρουσιαστούν ορισμένες ενδεικτικές εκτελέσεις του προγράμματος.

Αρχικά αν το πρόγραμμα τρέξει χωρίς ακριβώς πέντε ορίσματα τότε τερματίζεται με κωδικό εξόδου 1, που δηλώνει σφάλμα, και εκτυπώνεται αντίστοιχο μήνυμα για το πώς πρέπει να γίνει η χρήση του.

**Παράδειγμα 1**
```sh
$ ./factor
Usage: ./factor <semiprime>
$ echo $?
1
```

Θα παρουσιαστούν ορισμένα παραδείγματα σωστής χρήσης του προγράμματος για συγκεκριμένους ημιπρώτους αριθμούς. Οι προδιαγραφές του project αναφέρουν πως το πρόγραμμα θα πρέπει να έχει την δυνατότητα να εμφανίζει τα αποτέλσματα παραγοντοποίσης του ημιπρώτου που  δίνεται στην είσοδο σε λιγότερο από 10 δευτερόλεπτα. Αν θέλετε να εξετάσετε τον χρόνο εκτέλεσης του για τα παρακάτω παραδείγματα αξιοποιήστε την εντολή `time` (παράδειγμα 2.1).

**Παράδειγμα 2.1**
```sh
$ time ./factor 93
Factors: 3 31

real    0m0.020s
user    0m0.001s
sys     0m0.000s
$ echo $?
0
```

**Παράδειγμα 2.2**
```sh
$ ./factor 243014707258800662149
Factors: 41847874513 5807097973
$ echo $?
0
```
**Παράδειγμα 2.3**
```sh
$ ./factor 12174004519252065730760521
Factors: 3157210296241 3855937165081
$ echo $?
0
```

**Παράδειγμα 2.4**
```sh
$ ./factor 100000000000880000000001887
Factors: 10000000000051 10000000000037
$ echo $?
0
```

## Υλοποίηση

Κατ'αρχάς είναι σημαντικό να αναφερθεί ότι οι πηγές [<a href="#source1">1</a>],[<a href="#source3">2</a>],[<a href="#source5">3</a>],[<a href="#source7">4</a>],[<a href="#source11">5</a>] πέρα από την λογική επεξήγηση των αλγοριθμών περιείχαν και κομμάτια κώδικα τα οποία αξιοποιήθηκαν με κάποιες αλλαγές έτσι ώστε να υλοποιηθεί πλήρως και αποτελεσματικά ο αλγόριθμος Pollard's Rho.


1. ### `__int128` 

Το πρόγραμμα αξιοποιεί τον τύπο `__int128` για τη διαχείριση 128-bit ακεραίων αριθμών. Ο `__int128` χρησιμοποιείται για να υποστηρίξει πράξεις με πολύ μεγάλους αριθμούς, απαραίτητους στην παραγοντοποίηση ημιπρώτων αριθμών.
Η υλοποίηση περιλαμβάνει ειδικές συναρτήσεις όπως:

- abs128(): Υπολογίζει την απόλυτη τιμή ενός 128-bit αριθμού.

- modmul(): Υλοποιεί modular multiplication αποφεύγοντας την υπερχείλιση.
 
- print_int128(): Εκτυπώνει 128-bit αριθμούς χαρακτήρα-χαρακτήρα, καθώς οι συνηθισμένες συναρτήσεις εκτύπωσης (π.χ. printf) δεν τους υποστηρίζουν.
    
- atoint128(): Μετατρέπει μια συμβολοσειρά σε 128-bit αριθμό, επιτρέποντας την είσοδο πολύ μεγάλων τιμών από τη γραμμή εντολών.

2. ### `abs128`: Απόλυτη τιμή 128-bit ακέραιου

<ins>Πρόβλημα:</ins> Ο αλγόριθμος Pollard's Rho υπολογίζει τη διαφορά μεταξύ δύο αριθμών για να βρει τον ΜΚΔ(GCD). Όμως, οι αρνητικοί 128-bit αριθμοί (__int128) δεν υποστηρίζουν την κλασική συνάρτηση abs() που υπάρχει στην math.h που υπολογίζει την απόλυτη τιμή. Για αυτόν τον λόγο, υλοποιούμε μία συνάρτηση που:

- Ελέγχει αν ο αριθμός είναι αρνητικός.

- Αν είναι αρνητικός, επιστρέφει το αντίθετό του.

- Αν είναι θετικός, τον επιστρέφει όπως είναι.

Αυτό επιτρέπει στον αλγόριθμο να επεξεργάζεται χωρίς λάθη μεγάλες διαφορές αριθμών.

<ins>Υλοποίηση:</ins> Η συνάρτηση abs128 υπολογίζει την απόλυτη τιμή ενός 128-bit ακεραίου αριθμού. Η συνηθισμένη συνάρτηση abs() δεν μπορεί να χρησιμοποιηθεί απευθείας σε τύπους __int128. Για την επίλυση αυτού του περιορισμού, ελέγχεται αν ο αριθμός είναι αρνητικός και, σε αυτήν την περίπτωση, επιστρέφεται το αντίθετο του αριθμού. Αν είναι θετικός, επιστρέφεται ο αριθμός όπως είναι. Αυτή η υλοποίηση είναι σημαντική για τον Pollard's Rho, καθώς στη διαδικασία υπολογισμού του GCD, η συνάρτηση πρέπει να χειρίζεται διαφορές αριθμών χωρίς να προκαλούνται σφάλματα λόγω αρνητικών τιμών.

3. ### `gcd`: Μέγιστος Κοινός Διαιρέτης 128-bit αριθμών

<ins>Πρόβλημα:</ins> Ο υπολογισμός του Μέγιστου Κοινού Διαιρέτη (GCD) είναι το κλειδί στην υλοποίηση του Pollard's Rho. Ο αλγόριθμος απαιτεί την εύρεση του GCD δύο αριθμών, οι οποίοι μπορεί να είναι 128-bit ακέραιοι. Η συνηθισμένη συνάρτηση gcd δεν λειτουργεί με τύπους __int128.

<ins>Υλοποίηση:</ins> Η συνάρτηση gcd υλοποιεί τον αλγόριθμο του Ευκλείδη για τον υπολογισμό του GCD δύο 128-bit ακεραίων αριθμών. Η συνάρτηση εκτελεί επαναλαμβανόμενες διαιρέσεις με υπόλοιπο(mod) μέχρι το υπόλοιπο να γίνει μηδέν, επιστρέφοντας τον τελευταίο μη μηδενικό αριθμό. Αυτή η υλοποίηση είναι απαραίτητη για τη σύγκριση και την εύρεση μη απλών διαιρετών στον Pollard's Rho, καθώς ο GCD αποκαλύπτει τους παράγοντες των ημιπρώτων αριθμών [<a href="#source1">1</a>].

4. ### `modmul`: Πολλαπλασιασμός με Modulo 128-bit αριθμών

<ins>Πρόβλημα:</ins> Στον αλγόριθμο Pollard's Rho, απαιτείται ο υπολογισμός εκθετικών και πολλαπλασιαστικών τιμών χρησιμοποιώντας τον τύπο mod n, όπου n είναι ο αριθμός που αποδομούμε. Όταν οι αριθμοί που χρησιμοποιούμε είναι μεγάλοι, όπως 128-bit αριθμοί, οι κλασικοί υπολογισμοί μπορεί να προκαλέσουν υπερχείλιση (overflow).

<ins>Υλοποίηση:</ins> Η συνάρτηση modmul [<a href="#source5">2</a>] υλοποιεί τον ασφαλή πολλαπλασιασμό δύο 128-bit ακεραίων αριθμών υπό mod n χωρίς υπερχείλιση. Ο πολλαπλασιασμός γίνεται με διαδοχικές πράξεις πρόσθεσης και mod για την αποφυγή υπερχείλισης. Η ιδέα πίσω από αυτόν τον αλγόριθμο είναι η διαδοχική προσθήκη και διπλασιασμός του x με τη χρήση των bits του y. Έτσι, αντί να κάνουμε τον απλό πολλαπλασιασμό × * y, το αποτέλεσμα υπολογίζεται ορθά μέσω της ακολουθίας των παρακάτω βημάτων:

- Αρχική μείωση (mod): Πριν αρχίσουμε, περιορίζουμε τα x και y με mod για να αποφύγουμε μεγάλους αριθμούς.

- bitwise shift x : Ο αριθμός x διπλασιάζεται κάθε φορά, χρησιμοποιώντας την πράξη x+=x, η οποία είναι ισοδύναμη με το bitwise shift αριστερά (ισοδύναμο με τον πολλαπλασιασμό του x με 2). Το διπλασιασμένο x χρησιμοποιείται για να υπολογίσουμε τον πολλαπλασιασμό με το επόμενο bit του y [<a href="#source3">3</a>].

- Πρόσθεση του x στο αποτέλεσμα: Αν το τελευταίο bit του y είναι 1 (το οποίο ελέγχεται με την πράξη y & 1), προσθέτουμε το xx στο αποτέλεσμα. Αν το αποτέλεσμα είναι μεγαλύτερο ή ίσο από το mod, το μειώνουμε με mod για να διατηρήσουμε τους αριθμούς εντός των ορίων του mod.

- Shift του y: Για να περάσουμε στο επόμενο bit του y, το y μετακινείται δεξιά με την πράξη y>>=1.

- Συνέχεια της διαδικασίας: Αυτή η διαδικασία συνεχίζεται μέχρι το y να γίνει 0. Κάθε βήμα επεξεργάζεται ένα bit του y και αναδιατάσσει το x, υπολογίζοντας το τελικό αποτέλεσμα.

5. ### `rho`: Εύρεση διαιρέτη

<ins>Πρόβλημα:</ins> Ο κύριος στόχος του Pollard's Rho είναι η εύρεση ενός  διαιρέτη του ημιπρώτου αριθμού semi. Για την επίτευξη αυτού, χρειάζεται μία συνάρτηση που θα εφαρμόζει τη βασική λογική του αλγορίθμου Pollard's Rho.

<ins>Υλοποίηση:</ins> 
Το Pollard's Rho είναι ένας αλγόριθμος παραγοντοποίησης αριθμών που χρησιμοποιεί μια στοχαστική μέθοδο για την εύρεση παραγόντων ενός συνθετικού αριθμού. Η βασική ιδέα του αλγορίθμου είναι η εφαρμογή της συνάρτησης f(x)=($x^{2}$+c) mod semi για να δημιουργηθεί μια ακολουθία από τιμές, οι οποίες στη συνέχεια συγκρίνονται για να βρουν έναν κοινό παράγοντα με το semi [<a href="#source7">4</a>].

Ο αλγόριθμος λειτουργεί ως εξής:

- Ξεκινάμε με τυχαίες τιμές για τα x και y.

- Υπολογίζουμε την συνάρτηση f(x) για να παράγουμε νέες τιμές για το x και το y.
    
- Υπολογίζουμε το ΜΚΔ της διαφοράς τους και του αριθμού semi.
    
- Αν βρεθεί ΜΚΔ που είναι διαφορετικό από 1 ή το ίδιο με το semi, επιστρέφουμε τον παράγοντα.
    
- Επαναλαμβάνουμε τη διαδικασία μέχρι να βρούμε έναν παράγοντα ή να αποτύχουμε.

6. ### `atoint128`: Μετατροπή συμβολοσειράς σε 128-bit ακέραιο

<ins>Πρόβλημα:</ins> Κατά την είσοδο δεδομένων από τον χρήστη ή από αρχείο, οι αριθμοί εισάγονται ως strings. Οι τυπικές συναρτήσεις όπως atoi ή strtoll δεν μπορούν να χειριστούν 128-bit ακέραιους αριθμούς, με αποτέλεσμα την ανάγκη υλοποίησης μιας συνάρτησης που θα πραγματοποιεί τη μετατροπή αυτή.

<ins>Υλοποίηση:</ins> Η συνάρτηση atoint128 διαβάζει μία συμβολοσειρά που περιέχει έναν αριθμό και τη μετατρέπει σε __int128. Ακολουθεί τα παρακάτω βήματα:

- Αρχικοποίηση: Ελέγχεται το πρόσημο του αριθμού και γίνεται αρχικοποίηση κατάλληλων μεταβλητών.
    
- Ανάγνωση ψηφίων: Διατρέχει τη συμβολοσειρά χαρακτήρα προς χαρακτήρα, μετατρέποντας τα ψηφία σε ακέραιες τιμές και πολλαπλασιάζοντας το αποτέλεσμα με το 10 για κάθε νέο ψηφίο.
    
- Επιστροφή αριθμού: Συνυπολογίζει το πρόσημο και επιστρέφει τον αριθμό ως __int128.

Η συνάρτηση atoint128 είναι απαραίτητη για την ορθή είσοδο αριθμών μεγάλης ακρίβειας. Χωρίς αυτήν, το πρόγραμμα δεν θα μπορούσε να διαβάσει ημιπρώτους αριθμούς με 128-bit ακρίβεια.

7. ### `print_int128`: Εκτύπωση 128-bit ακεραίου αριθμού

<ins>Πρόβλημα:</ins> Οι τυπικές συναρτήσεις εκτύπωσης, όπως η printf, δεν υποστηρίζουν τον τύπο __int128. Χρειάζεται, λοιπόν, μία συνάρτηση που θα εκτυπώνει 128-bit ακέραιους αριθμούς.

<ins>Υλοποίηση:</ins> 
Η συνάρτηση `print_int128` εκτυπώνει έναν 128-bit ακέραιο αριθμό με τους εξής τρόπους:

- Διαχωρισμός αριθμού: Επαναλαμβανόμενες διαιρέσεις με το 10 χρησιμοποιούνται για να διαχωριστούν τα ψηφία του αριθμού.
    
- Αποθήκευση ψηφίων: Τα ψηφία αποθηκεύονται σε έναν πίνακα προσωρινά.
    
- Εκτύπωση: Τα ψηφία εκτυπώνονται με αντίστροφη σειρά για να εμφανιστεί σωστά ο αριθμός.



8. ### `Xorshift128+`:  Παραγωγή Τυχαίων Αριθμών

Η συνάρτηση xorshift128plus βοηθάει στην παραγοντοποίηση μέσω του αλγορίθμου Pollard's Rho δημιουργώντας τυχαίες τιμές για τη μεταβλητή c. Ο αλγόριθμος Pollard's Rho είναι επαναληπτικός και για να λειτουργήσει σωστά βασίζεται σε διαφορετικές αρχικές τιμές ή παραμέτρους. Η χρήση των τυχαίων αριθμών αυξάνει την πιθανότητα εύρεσης των παραγόντων ενός αριθμού [[<a href="#source10">5</a>]]. 


Ο Pollard's Rho επιχειρεί να παραγοντοποιήσει έναν ημιπρώτο αριθμό N με βάση την ιδιότητα ότι σε κάποια σημεία της επανάληψης οι τιμές των μεταβλητών θα συγκλίνουν σε κοινά υπόλοιπα.

Ο Pollard's Rho χρησιμοποιεί μια συνάρτηση επανάληψης της μορφής:

x<sub>n+1</sub>=f(x<sub>n</sub>)mod  N

όπου f(x) είναι μια συνάρτηση, συνήθως:

f(x)= $x^{2}$ + c mod  N

Το c είναι μια σταθερά που καθορίζει τη συνάρτηση επανάληψης. Διαφορετικές τιμές του c δημιουργούν διαφορετικές τροχιές στο υπολοιπικό σύστημα του αριθμού N(δηλαδή στο σύνολο όλων των υπολοίπων που μπορείς να πάρεις όταν διαιρείς έναν αριθμό με το N).


Ο κώδικας εκτελεί έναν βρόχο 100 επαναλήψεων με διαφορετική τυχαία τιμή του c σε κάθε επανάληψη:

   ```c
   for (int i = 1; i <= 100; i++) {
    i128 c = (better_rand() % (semi - 2)) + 1;
    if (rho(semi, &p, &q, c) == 0) {
        printf("Factors: ");
        print_int128(p);
        printf(" ");
        print_int128(q);
        printf("\n");
        return 0;
    }
   }
   ```
   Το Xorshift128+ ,λοιπόν, χρησιμοποιείται για να δημιουργήσει διαφορετικές τιμές c, οι οποίες βοηθούν τον Pollard's Rho να εξερευνήσει πολλές διαφορετικές "διαδρομές" στο υπολοιπικό σύστημα του N. Αυτό αυξάνει σημαντικά τις πιθανότητες να βρεθούν οι παράγοντες, ακόμα κι αν ο αλγόριθμος αποτύχει αρχικά.

    

## Πηγές

1. Αλγόριθμος του Ευκλείδη: <a id="source1" href="https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/the-euclidean-algorithm">euclidean-algorithm<a>  ,   <a id="source2" href="https://en.wikipedia.org/wiki/Euclidean_algorithm">euclidean-algorithm2</a>

2. Modular Multiplicaton(modmul): <a id="source3" href="https://www.geeksforgeeks.org/modular-multiplication/">modmul<a> , <a id="source4" href="https://en.wikipedia.org/wiki/Modular_arithmetic">modmul2<a>

3. Bitwise shift: <a id="source5" href="https://www.geeksforgeeks.org/left-shift-right-shift-operators-c-cpp/">Bitwise shift<a> , <a id="source6" href="https://stackoverflow.com/questions/141525/what-are-bitwise-shift-bit-shift-operators-and-how-do-they-work">Bitwise shift2<a>

4. Pollard's Rho: <a id="source7" href="https://www.geeksforgeeks.org/pollards-rho-algorithm-prime-factorization/">rho<a> , <a id="source8" href="https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm">pollard's rho<a> , <a id="source9" href="http://www.diva-portal.org/smash/get/diva2:1330398/FULLTEXT01.pdf">rho method<a> ,<a id="source10" href="https://en.wikipedia.org/wiki/Cycle_detection">cycle detection<a>

5. Xorshift128+: <a id="source11" href="https://en.wikipedia.org/wiki/Xorshift">Xorshift<a> , <a id="source12" href="https://stackoverflow.com/questions/34426499/what-is-the-real-definition-of-the-xorshift128-algorithm">xorshift128<a>


## Άδεια(License)

Αυτό το έργο είναι αδειοδοτημένο υπό την **MIT License**. 

### Επιτρέπεται:

- Η χρήση του κώδικα για οποιονδήποτε σκοπό.
- Η τροποποίηση και η προσαρμογή του κώδικα.
- Η διανομή του κώδικα, υπό την προϋπόθεση ότι θα αναφέρεται η αρχική άδεια.

### Δεν επιτρέπεται:

- Η αποκοπή της άδειας από τον κώδικα.

### MIT License

Copyright (c) 2024 Spyros Maichosoglou

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to use the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
***
